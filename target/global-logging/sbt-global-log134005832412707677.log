[0m[[0m[0mdebug[0m] [0m[0m> Exec(collectAnalyses, None, Some(CommandSource(network-1)))[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: initialized: JsonRpcNotificationMessage(2.0, initialized, {})[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///Users/dmukherjee/UIUC/SandiaTrack/ActorTrackAndDetect/akka-cluster/src/main/scala/sample/cluster/stats/App.scala","languageId":"scala","version":1,"text":"package sample.cluster.stats\n\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.receptionist.Receptionist\nimport akka.actor.typed.receptionist.ServiceKey\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.actor.typed.scaladsl.Routers\nimport akka.cluster.typed.Cluster\nimport com.typesafe.config.ConfigFactory\n\nobject App {\n\n  val StatsServiceKey = ServiceKey[StatsService.ProcessText](\"StatsService\")\n\n  private object RootBehavior {\n    def apply(): Behavior[Nothing] = Behaviors.setup[Nothing] { ctx =>\n      val cluster = Cluster(ctx.system)\n      if (cluster.selfMember.hasRole(\"compute\")) {\n        // on every compute node there is one service instance that delegates to N local workers\n        val numberOfWorkers =\n          ctx.system.settings.config.getInt(\"stats-service.workers-per-node\")\n        val workers = ctx\n          .spawn(\n            Routers\n              .pool(numberOfWorkers)(StatsWorker().narrow[StatsWorker.Process])\n              // the worker has a per word cache, so send the same word to the same local worker child\n              .withConsistentHashingRouting(1, _.word),\n            \"WorkerRouter\"\n          )\n        val service = ctx.spawn(StatsService(workers), \"StatsService\")\n\n        // published through the receptionist to the other nodes in the cluster\n        ctx.system.receptionist ! Receptionist\n          .Register(StatsServiceKey, service)\n      }\n      if (cluster.selfMember.hasRole(\"client\")) {\n        val serviceRouter =\n          ctx.spawn(Routers.group(App.StatsServiceKey), \"ServiceRouter\")\n        ctx.spawn(StatsClient(serviceRouter), \"Client\")\n      }\n      Behaviors.empty[Nothing]\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    if (args.isEmpty) {\n      startup(\"compute\", 25251)\n      startup(\"compute\", 25252)\n      startup(\"compute\", 0)\n      startup(\"client\", 0)\n    } else {\n      require(args.length == 2, \"Usage: role port\")\n      startup(args(0), args(1).toInt)\n    }\n  }\n\n  private def startup(role: String, port: Int): Unit = {\n\n    // Override the configuration of the port when specified as program argument\n    val config = ConfigFactory\n      .parseString(s\"\"\"\n      akka.remote.artery.canonical.port=$port\n      akka.cluster.roles = [$role]\n      \"\"\")\n      .withFallback(ConfigFactory.load(\"stats\"))\n\n    ActorSystem[Nothing](RootBehavior(), \"ClusterSystem\", config)\n  }\n}\n"}})[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///Users/dmukherjee/UIUC/SandiaTrack/ActorTrackAndDetect/akka-cluster/src/main/scala/sample/cluster/actordetrack/DroneManager.scala","languageId":"scala","version":1,"text":"package sample.cluster.actordetrack\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.actor.typed.receptionist.Receptionist\n\n\nobject DroneManager{\n    \n    def apply():Behavior[Receptionist.Listing] ={\n        Behaviors.setup[Receptionist.Listing]{ ctx=>\n            ctx.log.info(\"[DRONE]Manager Started\")\n            // ctx.system.receptionist ! Receptionist.Subscribe(App.DroneServiceKey, ctx.self)\n            ctx.system.receptionist ! Receptionist.Subscribe(DroneNode.DroneServiceKey, ctx.self)\n            Behaviors.receiveMessagePartial[Receptionist.Listing]{\n            case DroneNode.DroneServiceKey.Listing(listings) =>\n              listings.foreach{ps => \n                ps ! DroneNode.Start\n                ctx.log.info(\"[DRONE] New Drone Started\")\n              }\n              Behaviors.same\n          }\n\n        }\n    }\n}"}})[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":4,"message":"Processing"})[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Compile / collectAnalyses[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: Signal, check cycles: false, forcegc: true[0m[0J
[0m[[0m[0mdebug[0m] [0m[0manalysis location (/Users/dmukherjee/UIUC/SandiaTrack/ActorTrackAndDetect/target/scala-2.12/zinc/inc_compile_2.12.zip,true)[0m[0J
[0m[[0m[32msuccess[0m] [0m[0mTotal time: 0 s, completed Nov 2, 2023 4:02:01 PM[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":4,"message":"Done"})[0m[0J
[0m[[0m[0mdebug[0m] [0m[0m> Exec(shell, None, None)[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///Users/dmukherjee/UIUC/SandiaTrack/ActorTrackAndDetect/detectandtrack/src/main/scala/com/example/AkkaKalman.scala","languageId":"scala","version":1,"text":"//#full-example\n//#currently using example from https://commons.apache.org/proper/commons-math/userguide/filter.html\npackage com.example\n\n\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\nimport scala.concurrent.duration._\nimport scala.util.Random\nimport org.apache.commons.math3.filter._\nimport org.apache.commons.math3.linear._\nimport org.apache.commons.math3.random.{JDKRandomGenerator, RandomGenerator}\nimport akka.actor.Actor\n\nsealed trait EstimatorReceivable\nfinal case class MyAddr(addr: ActorRef[EstimatorReceivable]) extends EstimatorReceivable\nfinal case class Measurement(realVec: ArrayRealVector, replyTo: ActorRef[Estimate]) extends EstimatorReceivable\nfinal case object Timeout extends EstimatorReceivable\nfinal case class Estimate(estimate: Double)\nfinal case class StartGenerate()\n\nobject Estimator {\n  /*\n    Behaviour value. fixed value associated with each Estimator\n    Common for each estimator\n  */\n  val constantVoltage = 10.0\n  val measurementNoise = 1.0\n  val processNoise = 1e-5\n  \n  class MyData {\n  // A = [ 1 ]\n  val A = new Array2DRowRealMatrix(Array(1.0))\n\n  // B = null\n  val B: RealMatrix = null\n\n  // H = [ 1 ]\n  val H = new Array2DRowRealMatrix(Array(1.0))\n\n  // x = [ 10 ]\n  var x = new ArrayRealVector(Array(constantVoltage))\n\n  // Q = [ 1e-5 ]\n  val Q = new Array2DRowRealMatrix(Array(processNoise))\n\n  // P = [ 1 ]\n  val P0 = new Array2DRowRealMatrix(Array(1.0))\n\n  // R = [ 0.1 ]\n  val R = new Array2DRowRealMatrix(Array(measurementNoise))\n\n  val pm = new DefaultProcessModel(A, B, Q, x, P0)\n  val mm = new DefaultMeasurementModel(H, R)\n  val filter = new KalmanFilter(pm, mm)\n  }\n\n\n  var FellowActor: Set[ActorRef[EstimatorReceivable]] = Set() // Created a set of actor to add for collecting and sending information \n\n  private def addToSet(ref: ActorRef[EstimatorReceivable]): Unit ={\n    FellowActor = FellowActor+ref\n  }\n\n  def apply(): Behavior[EstimatorReceivable] = idle(new MyData())\n\n  def estimating(realVec: ArrayRealVector, replyTo: ActorRef[Estimate]): Behavior[EstimatorReceivable] = Behaviors.setup { context =>\n    filter.predict();\n\n    filter.correct(realVec);\n\n    val voltage = filter.getStateEstimation()(0)\n    replyTo ! Estimate(voltage)\n    Behaviors.same\n  }\n\n  def addingNewFellow(addr: ActorRef[EstimatorReceivable]): Behavior[EstimatorReceivable] = Behaviors.setup { context =>\n    addToSet(addr)\n    context.log.info(\"Adding a new fellow to my list\")\n    Behaviors.same\n\n  }\n\n  def idle(mydata : MyData): Behavior[EstimatorReceivable] = Behaviors.withTimers { timer =>\n    timer.startSingleTimer(Timeout, 5.second)\n    Behaviors.receive { (context, message) =>\n      message match {\n        case Measurement(realVec, replyTo) =>\n          mydata.haveIReceivedMeasurementYet = true\n          timer.cancel(Timeout)\n          estimating(realVec, replyTo)\n          idle(mydata)\n        \n        case MyAddr(addr) =>\n          addingNewFellow(addr)\n                 \n        case Timeout =>\n          context.log.info(\"Timed out...\")\n          if (mydata.haveIReceivedMeasurementYet) {\n            Behaviors.same\n          }\n          else {\n            probation(mydata)\n          }\n        \n        case _ =>\n          Behaviors.same\n      }\n    }\n  }\n\n  def probation(mydata : MyData): Behavior[EstimatorReceivable] = Behaviors.withTimers { timer =>\n    timer.startSingleTimer(Timeout, 5.second)\n    Behaviors.receive { (context, message) =>\n      message match {\n        case Measurement(realVec, replyTo) =>\n          mydata.haveIReceivedMeasurementYet = true\n          estimating(realVec, replyTo)\n        \n        case MyAddr(addr) =>\n          addingNewFellow(addr)\n                 \n        case Timeout =>\n          context.log.info(\"Timed out...\")\n          if (mydata.haveIReceivedMeasurementYet) {\n            Behaviors.same\n          }\n          else {\n            probation(mydata)\n          }\n        \n        case _ =>\n          Behaviors.same\n      }\n    }\n\n}\n\nobject Generator {\n  // Constants\n  val constantVoltage = 10.0\n  val measurementNoise = 1\n  val processNoise = 1e-5\n  val numMeasurements = 10\n\n  // x = [ 10 ]\n  var x = new ArrayRealVector(Array(constantVoltage))\n\n  // Process and measurement noise vectors\n  val pNoise = new ArrayRealVector(Array(0.0))\n  val mNoise = new ArrayRealVector(Array(0.0))\n\n  def apply(estimator: ActorRef[Measurement]): Behavior[Estimate] = generating(estimator, 0)\n\n  private def generating(estimator: ActorRef[Measurement], messageCounter: Int): Behavior[Estimate] =\n  Behaviors.setup { context =>\n    // Randomly crash generator to test timeout\n    if (Random.nextInt() % 3 == 0 || messageCounter == numMeasurements) {\n      Behaviors.stopped\n    } else {\n      // simulate the process\n      pNoise.setEntry(0, processNoise * Random.nextGaussian());\n\n      // x = A * x + p_noise\n      x.add(pNoise)\n\n      // simulate the measurement\n      mNoise.setEntry(0, measurementNoise * Random.nextGaussian());\n\n      // z = H * x + m_noise\n      val z = x.add(mNoise)\n\n      context.log.info(s\"Sending measurement: ${z.getEntry(0)}\")\n      estimator ! Measurement(z, context.self)\n      idle(estimator, messageCounter + 1)\n    }\n  }\n\n  private def idle(estimator: ActorRef[Measurement], messageCounter: Int): Behavior[Estimate] = Behaviors.receive { (context, message) =>\n    context.log.info(s\"Received estimate: ${message.estimate}\")\n    generating(estimator, messageCounter)\n  }\n}\n/*\nGenerating the actor system \n*/\nobject KalmanMain {\n  def apply(): Behavior[StartGenerate] =\n    Behaviors.setup { context =>\n      //#create-actors\n      val estimator1_1 = context.spawn(Estimator(), \"estimator\")\n      val estimator1_2 = context.spawn(Estimator(), \"estimator1\")\n      estimator1_1 ! MyAddr(estimator1_2)\n      estimator1_2 ! MyAddr(estimator1_1)\n      val generator = context.spawn(Generator(estimator1_1), \"generator\")\n      val generator1 = context.spawn(Generator(estimator1_2), \"generator1\")\n      //#create-actors\n      Behaviors.same\n    }\n}\n\n//#main-class\nobject AkkaQuickstart extends App {\n  val kalmanMain = ActorSystem[StartGenerate](KalmanMain(), \"generator-estimator\")\n  kalmanMain ! StartGenerate()\n}\n//#main-class\n//#full-example\n"}})[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///Users/dmukherjee/UIUC/SandiaTrack/ActorTrackAndDetect/akka-cluster/src/main/scala/sample/cluster/actordetrack/App.scala","languageId":"scala","version":1,"text":"package sample.cluster.actordetrack\n\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.receptionist.Receptionist\nimport akka.actor.typed.receptionist.ServiceKey\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.actor.typed.scaladsl.Routers\nimport akka.cluster.typed.Cluster\nimport com.typesafe.config.ConfigFactory\n\nobject App {\n\n  // val DroneServiceKey = ServiceKey[DroneNode.Event](\"DroneService\")\n\n  //final case class DroneService(replyTo: ActorRef[DroneNode.Start])\n  \n  private object Drone{\n    def apply(): Behavior[Nothing] = Behaviors.setup[Nothing]{ ctx =>\n      val cluster = Cluster(ctx.system)\n      if (cluster.selfMember.hasRole(\"Drone\")){\n        // Spawning a drone\n          val drone = ctx.spawn(DroneNode(),\"Drone\")\n          // registering it to the key\n          // ctx.system.receptionist ! Receptionist.Register(DroneServiceKey,drone)\n      }\n\n\n      if(cluster.selfMember.hasRole(\"DroneManager\")){\n        // Look at all the drone that are joining\n        // Ignore for now\n        ctx.spawn(DroneManager(),\"DroneManager\")\n      }\n\n\n      Behaviors.empty[Nothing]\n\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n      startup(\"DroneManager\",25251) \n      startup(\"Drone\", 25255)\n\n      startup(\"Drone\", 25256)\n\n      startup(\"Drone\", 25257)\n      // startup(\"DroneManager\", 0)\n  }\n  private def startup(role:String, port: Int): Unit ={\n     val config = ConfigFactory\n      .parseString(s\"\"\"\n      akka.remote.artery.canonical.port=$port\n      akka.cluster.roles = [$role]\n      \"\"\")\n      .withFallback(ConfigFactory.load(\"drone\"))\n    \n      ActorSystem[Nothing](Drone(), \"ClusterSystem\", config)\n  }\n}\n"}})[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///Users/dmukherjee/UIUC/SandiaTrack/ActorTrackAndDetect/akka-cluster/src/main/scala/sample/cluster/actordetrack/MyDrone.scala","languageId":"scala","version":1,"text":"package sample.cluster.actordetrack\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.actor.typed.receptionist.ServiceKey\nimport akka.actor.typed.receptionist.Receptionist\n\n\nimport scala.concurrent.duration._\n\nobject DroneNode{\n    trait Event\n    case object Start extends Event\n\n    val DroneServiceKey = ServiceKey[Event](\"DroneService\")\n    \n    def apply(): Behavior[Event] = \n        Behaviors.setup{ ctx =>\n            // Need to spawn the sensors\n            ctx.system.receptionist ! Receptionist.Register(DroneNode.DroneServiceKey, ctx.self)\n            Behaviors.receiveMessage{\n                case Start =>\n                    ctx.log.info(\"[DRONE]Started the node\")\n                    Behaviors.same\n            }\n\n        }\n\n\n\n}"}})[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mForcing garbage collection...[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didClose: JsonRpcNotificationMessage(2.0, textDocument/didClose, {"textDocument":{"uri":"file:///Users/dmukherjee/UIUC/SandiaTrack/ActorTrackAndDetect/detectandtrack/src/main/scala/com/example/AkkaKalman.scala"}})[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mUnhandled request received: shutdown: JsonRpcRequestMessage(2.0, â™¨1, shutdown, null})[0m[0J
